//go:build go1.22

// Package main provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package main

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes    = "BearerAuth.Scopes"
	SessionCookieScopes = "SessionCookie.Scopes"
)

// CartDetail defines model for CartDetail.
type CartDetail struct {
	Furniture *FurnitureListing `json:"furniture,omitempty"`

	// Id The unique identifier for the cart.
	Id *int `json:"id,omitempty"`

	// Quantity The quantity of the furniture in the cart.
	Quantity *int `json:"quantity,omitempty"`
}

// CartInput defines model for CartInput.
type CartInput struct {
	// FurnitureId The unique identifier for the furniture
	FurnitureId int `json:"furniture_id"`

	// Price Price per unit of the furniture item
	Price float32 `json:"price"`

	// Quantity Number of units for the furniture item
	Quantity int `json:"quantity"`
}

// CreateFurniture defines model for CreateFurniture.
type CreateFurniture struct {
	// AdditionalImageUrls Additional image urls for the furniture
	AdditionalImageUrls []string `json:"additional_image_urls"`

	// CategoryId The category of the furniture
	CategoryId int `json:"category_id"`

	// Description The description of the furniture
	Description string `json:"description"`

	// ImageUrl The image url of the furniture
	ImageUrl string `json:"image_url"`

	// Name The name of the furniture
	Name string `json:"name"`

	// Price The price of the furniture
	Price float32 `json:"price"`

	// Stock The amount in stock
	Stock int `json:"stock"`
}

// Error defines model for Error.
type Error struct {
	// Error Details about the error.
	Error struct {
		// Message Human-readable explanation of the error
		Message *string `json:"message,omitempty"`
	} `json:"error"`
}

// ErrorDetail Additional details of the error.
type ErrorDetail struct {
	// Field The name of the field that caused the validation error.
	Field string `json:"field"`

	// Message Description of what went wrong with the specific field
	Message string `json:"message"`
}

// ErrorWithDetails defines model for ErrorWithDetails.
type ErrorWithDetails struct {
	// Error Details about the error.
	Error struct {
		// Message Human-readable explanation of the error
		Message *string `json:"message,omitempty"`
	} `json:"error"`

	// Errors A list of field-specific validation errors
	Errors *[]ErrorDetail `json:"errors,omitempty"`
}

// FurnitureListing defines model for FurnitureListing.
type FurnitureListing struct {
	// Id The ID of the furniture
	Id int `json:"id"`

	// ImageUrl The main image of the furniture
	ImageUrl string `json:"image_url"`

	// Name The name of the furniture
	Name string `json:"name"`

	// Price The price of the furniture
	Price float32 `json:"price"`
}

// OrderDetail defines model for OrderDetail.
type OrderDetail struct {
	// CreatedAt Timestamp when the order was placed
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Id Unique ID of the order
	Id *int `json:"id,omitempty"`

	// IdentityId Ory Kratos user identity ID of the customer
	IdentityId *openapi_types.UUID `json:"identity_id,omitempty"`

	// Items List of items in the order
	Items *[]CartInput `json:"items,omitempty"`

	// PaymentStatus Status of the payment (e.g., paid, pending, failed)
	PaymentStatus *string `json:"payment_status,omitempty"`

	// ShippingAddressId ID of the address where the order is to be delivered
	ShippingAddressId *int `json:"shipping_address_id,omitempty"`

	// Status Current status of the order
	Status *string `json:"status,omitempty"`

	// TotalAmount Total amount charged for the order
	TotalAmount *float32 `json:"total_amount,omitempty"`

	// UpdatedAt Timestamp of the last update to the order
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// OrderInput defines model for OrderInput.
type OrderInput struct {
	// IdentityId Ory Kratos user identity ID of the customer
	IdentityId openapi_types.UUID `json:"identity_id"`

	// Items List of furniture items in the order.
	Items []CartInput `json:"items"`

	// ShippingAddressId ID of the shipping address for the order
	ShippingAddressId int `json:"shipping_address_id"`
}

// OrderList defines model for OrderList.
type OrderList struct {
	Items *[]struct {
		// CreatedAt Timestamp when the order was placed
		CreatedAt *time.Time `json:"created_at,omitempty"`

		// Id Unique ID of the order
		Id *int `json:"id,omitempty"`

		// PaymentStatus Status of the payment (e.g., paid, pending, failed)
		PaymentStatus *string `json:"payment_status,omitempty"`

		// ShippingAddressId ID of the address where the order is to be delivered
		ShippingAddressId *int `json:"shipping_address_id,omitempty"`

		// Status Current status of the order
		Status *string `json:"status,omitempty"`

		// TotalAmount Total amount charged for the order
		TotalAmount *float32 `json:"total_amount,omitempty"`
	} `json:"items,omitempty"`
}

// PaginationMetadata defines model for PaginationMetadata.
type PaginationMetadata struct {
	// CurrentPage The current page number.
	CurrentPage int `json:"current_page"`

	// PageSize The number of items per page.
	PageSize int `json:"page_size"`

	// TotalItems The total number of items across all pages.
	TotalItems int `json:"total_items"`

	// TotalPages The total number of pages.
	TotalPages *int `json:"total_pages,omitempty"`
}

// PaymentDetail defines model for PaymentDetail.
type PaymentDetail struct {
	// Amount Total amount paid
	Amount float32 `json:"amount"`

	// Id Unique payment record ID
	Id float32 `json:"id"`

	// OrderId ID of the order the payment is linked to
	OrderId int `json:"order_id"`

	// PaidAt Timestamp when payment was recorded
	PaidAt time.Time `json:"paid_at"`

	// PaymentMethod Method used to make the payment
	PaymentMethod string `json:"payment_method"`

	// Reference External transaction reference
	Reference string `json:"reference"`

	// Status Status of the payment (e.g., success, failed)
	Status string `json:"status"`
}

// PaymentInput defines model for PaymentInput.
type PaymentInput struct {
	// Amount Amount being paid
	Amount float32 `json:"amount"`

	// PaymentMethod Payment method used (e.g., card, bank_transfer, wallet)
	PaymentMethod string `json:"payment_method"`

	// Reference External payment provider transaction reference
	Reference *string `json:"reference,omitempty"`
}

// ReviewDetail defines model for ReviewDetail.
type ReviewDetail struct {
	// Comment User's comment about the furniture
	Comment *string `json:"comment,omitempty"`

	// CreatedAt When the review was submitted
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// FurnitureId ID of the furniture item reviewed
	FurnitureId *int `json:"furniture_id,omitempty"`

	// Id Unique identifier for the review
	Id *int `json:"id,omitempty"`

	// IdentityId Ory Kratos identity ID of the user who submitted the review
	IdentityId *openapi_types.UUID `json:"identity_id,omitempty"`

	// Rating Rating score
	Rating *int `json:"rating,omitempty"`
}

// ReviewInput defines model for ReviewInput.
type ReviewInput struct {
	// Comment Written feedback from the user
	Comment string `json:"comment"`

	// FurnitureId ID of the furniture item reviewed
	FurnitureId int `json:"furniture_id"`

	// IdentityId Ory Kratos identity ID of the reviewer
	IdentityId *string `json:"identity_id,omitempty"`

	// Rating Rating given by the user (1 to 5 stars)
	Rating int `json:"rating"`
}

// Success defines model for Success.
type Success struct {
	// Message Human-readable success message
	Message string `json:"message"`
}

// UpdateFurniture defines model for UpdateFurniture.
type UpdateFurniture struct {
	// AdditionalImageUrls Additional image urls for the furniture
	AdditionalImageUrls *[]string `json:"additional_image_urls,omitempty"`
	Category            *struct {
		// Id The category id
		Id *int `json:"id,omitempty"`

		// Name The name of the category
		Name *string `json:"name,omitempty"`
	} `json:"category,omitempty"`

	// Description The description of the furniture
	Description *string `json:"description,omitempty"`

	// Id The ID of the furniture
	Id *int `json:"id,omitempty"`

	// ImageUrl The url for the main image of the furniture
	ImageUrl *string `json:"image_url,omitempty"`

	// Name The name of the furniture
	Name *string `json:"name,omitempty"`

	// Price The price of the furniture
	Price *float32 `json:"price,omitempty"`

	// Stock The number of stock available
	Stock *int `json:"stock,omitempty"`
}

// CategoryQuery The filter for category
type CategoryQuery = string

// IdentityID defines model for IdentityID.
type IdentityID = openapi_types.UUID

// NameQuery The filter for the resource name
type NameQuery = string

// PageQuery The page number
type PageQuery = int

// PageSizeQuery The page_size
type PageSizeQuery = int

// PathID defines model for PathID.
type PathID = int

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Forbidden defines model for Forbidden.
type Forbidden = Error

// FurnitureCreated defines model for FurnitureCreated.
type FurnitureCreated struct {
	// Message Success message.
	Message *string `json:"message,omitempty"`
}

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// ListFurnitureSuccess defines model for ListFurnitureSuccess.
type ListFurnitureSuccess struct {
	// Items A list of furniture
	Items    *[]FurnitureListing `json:"items,omitempty"`
	Metadata *PaginationMetadata `json:"metadata,omitempty"`
}

// NotFound defines model for NotFound.
type NotFound = Error

// StatusOK defines model for StatusOK.
type StatusOK = Success

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity = ErrorWithDetails

// ListFurnitureHandlerParams defines parameters for ListFurnitureHandler.
type ListFurnitureHandlerParams struct {
	Name     *NameQuery     `form:"name,omitempty" json:"name,omitempty"`
	Page     *PageQuery     `form:"page,omitempty" json:"page,omitempty"`
	PageSize *PageSizeQuery `form:"page_size,omitempty" json:"page_size,omitempty"`
	Category *CategoryQuery `form:"category,omitempty" json:"category,omitempty"`
}

// UpdateReviewHandlerJSONBody defines parameters for UpdateReviewHandler.
type UpdateReviewHandlerJSONBody struct {
	// Comment Written feedback from the user
	Comment *string `json:"comment,omitempty"`

	// IdentityId Ory Kratos identity ID of the reviewer
	IdentityId *string `json:"identity_id,omitempty"`

	// Rating Rating given by the user (1 to 5 stars)
	Rating *int `json:"rating,omitempty"`
}

// CreateFurnitureHandlerJSONRequestBody defines body for CreateFurnitureHandler for application/json ContentType.
type CreateFurnitureHandlerJSONRequestBody = CreateFurniture

// UpdateFurnitureHandlerJSONRequestBody defines body for UpdateFurnitureHandler for application/json ContentType.
type UpdateFurnitureHandlerJSONRequestBody = UpdateFurniture

// PlaceOrderHandlerJSONRequestBody defines body for PlaceOrderHandler for application/json ContentType.
type PlaceOrderHandlerJSONRequestBody = OrderInput

// OrderPaymentHandlerJSONRequestBody defines body for OrderPaymentHandler for application/json ContentType.
type OrderPaymentHandlerJSONRequestBody = PaymentInput

// CreateReviewHandlerJSONRequestBody defines body for CreateReviewHandler for application/json ContentType.
type CreateReviewHandlerJSONRequestBody = ReviewInput

// UpdateReviewHandlerJSONRequestBody defines body for UpdateReviewHandler for application/json ContentType.
type UpdateReviewHandlerJSONRequestBody UpdateReviewHandlerJSONBody

// AddToCartHandlerJSONRequestBody defines body for AddToCartHandler for application/json ContentType.
type AddToCartHandlerJSONRequestBody = CartInput

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all furniture
	// (GET /furniture)
	ListFurnitureHandler(w http.ResponseWriter, r *http.Request, params ListFurnitureHandlerParams)
	// Create a new furniture
	// (POST /furniture)
	CreateFurnitureHandler(w http.ResponseWriter, r *http.Request)
	// Delete a specific furniture by ID
	// (DELETE /furniture/{id})
	DeleteFurniture(w http.ResponseWriter, r *http.Request, id PathID)
	// Get details of a specific furniture item by ID
	// (GET /furniture/{id})
	GetFurnitureHandler(w http.ResponseWriter, r *http.Request, id PathID)
	// Update a specific furniture item by ID.
	// (PATCH /furniture/{id})
	UpdateFurnitureHandler(w http.ResponseWriter, r *http.Request, id PathID)
	// Place an order
	// (POST /orders)
	PlaceOrderHandler(w http.ResponseWriter, r *http.Request)
	// Get details of a specific order
	// (GET /orders/{id})
	GetOrderDetailHandler(w http.ResponseWriter, r *http.Request, id PathID)
	// Make a payment for an order
	// (POST /orders/{id}/payment)
	OrderPaymentHandler(w http.ResponseWriter, r *http.Request, id PathID)
	// Submit a review for a specific furniture item
	// (POST /reviews)
	CreateReviewHandler(w http.ResponseWriter, r *http.Request)
	// Delete a review for a furniture item
	// (DELETE /reviews/{id})
	DeleteReviewHandler(w http.ResponseWriter, r *http.Request, id PathID)
	// Update an existing review for a furniture item
	// (PATCH /reviews/{id})
	UpdateReviewHandler(w http.ResponseWriter, r *http.Request, id PathID)
	// Retrieve a list of furniture in the cart for the User.
	// (GET /users/{identity_id}/cart)
	GetCartHandler(w http.ResponseWriter, r *http.Request, identityId IdentityID)
	// Add a furniture to cart
	// (POST /users/{identity_id}/cart)
	AddToCartHandler(w http.ResponseWriter, r *http.Request, identityId IdentityID)
	// List all orders associated with a specific user
	// (GET /users/{identity_id}/orders)
	ListOrdersForUserHandler(w http.ResponseWriter, r *http.Request, identityId IdentityID)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListFurnitureHandler operation middleware
func (siw *ServerInterfaceWrapper) ListFurnitureHandler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFurnitureHandlerParams

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_size", Err: err})
		return
	}

	// ------------- Optional query parameter "category" -------------

	err = runtime.BindQueryParameter("form", true, false, "category", r.URL.Query(), &params.Category)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "category", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListFurnitureHandler(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateFurnitureHandler operation middleware
func (siw *ServerInterfaceWrapper) CreateFurnitureHandler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateFurnitureHandler(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteFurniture operation middleware
func (siw *ServerInterfaceWrapper) DeleteFurniture(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id PathID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteFurniture(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetFurnitureHandler operation middleware
func (siw *ServerInterfaceWrapper) GetFurnitureHandler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id PathID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFurnitureHandler(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateFurnitureHandler operation middleware
func (siw *ServerInterfaceWrapper) UpdateFurnitureHandler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id PathID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateFurnitureHandler(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PlaceOrderHandler operation middleware
func (siw *ServerInterfaceWrapper) PlaceOrderHandler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PlaceOrderHandler(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetOrderDetailHandler operation middleware
func (siw *ServerInterfaceWrapper) GetOrderDetailHandler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id PathID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOrderDetailHandler(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// OrderPaymentHandler operation middleware
func (siw *ServerInterfaceWrapper) OrderPaymentHandler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id PathID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OrderPaymentHandler(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateReviewHandler operation middleware
func (siw *ServerInterfaceWrapper) CreateReviewHandler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateReviewHandler(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteReviewHandler operation middleware
func (siw *ServerInterfaceWrapper) DeleteReviewHandler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id PathID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteReviewHandler(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateReviewHandler operation middleware
func (siw *ServerInterfaceWrapper) UpdateReviewHandler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id PathID

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateReviewHandler(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetCartHandler operation middleware
func (siw *ServerInterfaceWrapper) GetCartHandler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "identity_id" -------------
	var identityId IdentityID

	err = runtime.BindStyledParameterWithOptions("simple", "identity_id", r.PathValue("identity_id"), &identityId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "identity_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCartHandler(w, r, identityId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddToCartHandler operation middleware
func (siw *ServerInterfaceWrapper) AddToCartHandler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "identity_id" -------------
	var identityId IdentityID

	err = runtime.BindStyledParameterWithOptions("simple", "identity_id", r.PathValue("identity_id"), &identityId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "identity_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddToCartHandler(w, r, identityId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListOrdersForUserHandler operation middleware
func (siw *ServerInterfaceWrapper) ListOrdersForUserHandler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "identity_id" -------------
	var identityId IdentityID

	err = runtime.BindStyledParameterWithOptions("simple", "identity_id", r.PathValue("identity_id"), &identityId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "identity_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListOrdersForUserHandler(w, r, identityId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       *http.ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m *http.ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m *http.ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/furniture", wrapper.ListFurnitureHandler)
	m.HandleFunc("POST "+options.BaseURL+"/furniture", wrapper.CreateFurnitureHandler)
	m.HandleFunc("DELETE "+options.BaseURL+"/furniture/{id}", wrapper.DeleteFurniture)
	m.HandleFunc("GET "+options.BaseURL+"/furniture/{id}", wrapper.GetFurnitureHandler)
	m.HandleFunc("PATCH "+options.BaseURL+"/furniture/{id}", wrapper.UpdateFurnitureHandler)
	m.HandleFunc("POST "+options.BaseURL+"/orders", wrapper.PlaceOrderHandler)
	m.HandleFunc("GET "+options.BaseURL+"/orders/{id}", wrapper.GetOrderDetailHandler)
	m.HandleFunc("POST "+options.BaseURL+"/orders/{id}/payment", wrapper.OrderPaymentHandler)
	m.HandleFunc("POST "+options.BaseURL+"/reviews", wrapper.CreateReviewHandler)
	m.HandleFunc("DELETE "+options.BaseURL+"/reviews/{id}", wrapper.DeleteReviewHandler)
	m.HandleFunc("PATCH "+options.BaseURL+"/reviews/{id}", wrapper.UpdateReviewHandler)
	m.HandleFunc("GET "+options.BaseURL+"/users/{identity_id}/cart", wrapper.GetCartHandler)
	m.HandleFunc("POST "+options.BaseURL+"/users/{identity_id}/cart", wrapper.AddToCartHandler)
	m.HandleFunc("GET "+options.BaseURL+"/users/{identity_id}/orders", wrapper.ListOrdersForUserHandler)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
